import{_ as a,r,o as l,c as i,b as e,d as o,a as d,e as n}from"./app-a4701f19.js";const t={},p=e("p",null,[o("Webpack 是一个用于现代 "),e("code",null,"JavaScript"),o(" 应用程序的静态模块打包工具")],-1),s={href:"https://webpack.js.org",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.webpackjs.com/",target:"_blank",rel:"noopener noreferrer"},b=n('<h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><ul><li><code>entry</code> 编译的入口文件</li><li><code>output</code> 如何输出以及在哪里输出</li><li><code>module</code> Webpack 一切皆模块，一个模块对应一个文件</li><li><code>chunk</code> 代码块，由多个 module 组成</li><li><code>loader</code> Webpack 通过不同的 loader 对模块的源代码进行转换</li><li><code>plugin</code> 插件 Webpack 在打包构建的生命周期中提供了不同的 hooks 允许调用方能够对打包的资源注入自己的逻辑处理</li><li><code>compiler</code> 编译器，把控整个 Webpack 打包的构建流程</li><li><code>compilation</code> 每一次构建的上下文对象包含了当次构建的所有信息</li><li><code>dependence</code> 记录模块间依赖关系</li></ul><h2 id="构建流程" tabindex="-1"><a class="header-anchor" href="#构建流程" aria-hidden="true">#</a> 构建流程</h2><h3 id="init-初始化阶段" tabindex="-1"><a class="header-anchor" href="#init-初始化阶段" aria-hidden="true">#</a> <code>Init</code> 初始化阶段</h3><p>1.解析命令行与 <code>webpack.config.js</code> 配置的参数，合并生成最后的配置<br> 2.创建 <code>compiler</code> 对象并开始启动插件<br>   1.调用 <code>createCompiler</code> 函数创建 <code>compiler</code> 对象<br>   2.遍历注册的 <code>Plugins</code> 并执行其 <code>apply</code> 方法<br>   3.调用 <code>new WebpackOptionsApply().process</code> 方法，根据配置内容动态注入相应插件<br>     1.调用 <code>EntryOptionPlugin</code> 插件，该插件根据 <code>entry</code> 值注入 <code>DynamicEntryPlugin</code> 或 <code>EntryPlugin</code> 插件<br>     2.根据 <code>devtool</code> 值注入 <code>Sourcemap</code> 插件<br>       1.<code>SourceMapDevToolPlugin</code><br>       2.<code>EvalSourceMapDevToolPlugin</code><br>       3.<code>EvalDevToolModulePlugin</code><br>     3.注入 <code>RuntimePlugin</code> 用于根据代码内容动态注入 webpack 运行时<br>   4.调用 <code>compiler.compile</code> 方法开始执行构建</p><h3 id="make-构建阶段" tabindex="-1"><a class="header-anchor" href="#make-构建阶段" aria-hidden="true">#</a> <code>Make</code> 构建阶段</h3><p>1.读入文件内容 2.调用 <code>Loader</code> 将模块转译为标准的 <code>JS</code> 内容 3.调用 <code>acorn</code> 生成 <code>AST</code> 语法树 4.分析 <code>AST</code> 确定模块依赖列表 5.解析模块依赖（对每一个依赖模块重新执行上述流程，直到生成完整的模块依赖图 —— <code>ModuleGraph</code> 对象）</p><h3 id="seal-生成阶段" tabindex="-1"><a class="header-anchor" href="#seal-生成阶段" aria-hidden="true">#</a> <code>Seal</code> 生成阶段</h3><p>1.遍历模块依赖图并执行操作<br>   1.代码转译，如 <code>import</code> 转换为 <code>require</code> 调用<br>   2.分析运行时依赖<br> 2.合并模块代码与运行时代码并生成 <code>chunk</code><br> 3.执行产物优化操作<br>   1.<code>Tree-shaking</code><br>   2.压缩<br>   3.<code>Code Split</code><br> 4.输出结果（根据配置确定输出的路径和文件名，把文件内容写入到文件系统）</p>',9);function u(k,m){const c=r("ExternalLinkIcon");return l(),i("div",null,[p,e("ul",null,[e("li",null,[e("a",s,[o("Webpack 英文官网"),d(c)])]),e("li",null,[e("a",h,[o("Webpack 中文官网"),d(c)])])]),b])}const f=a(t,[["render",u],["__file","webpack.html.vue"]]);export{f as default};
